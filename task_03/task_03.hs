module HW3 where

-------------------------------------------------------------------------------
-- Упр. 1: Установите интерпретатор ghci

-- Ответ:
--     ghci --version
--     The Glorious Glasgow Haskell Compilation System, version 9.4.7

-------------------------------------------------------------------------------
-- Упр. 2: Вычислите в интерпретаторе следующие выражения:
--         a.  1 + 1
--         b.  True == False
--         c.  5 + 7 * (-7 + 1)
--         d.  not True
--         e.  False && True || True
--         f.  2 * 2 /= 4
--         g.  succ 9
--         h.  max 5 15 + 4 + min 9 (-1)
-- Также определите в интерпретаторе определите их тип.
-- Заполните:
--    answer2(буква): строка - результат в интерпреторе.
--    answer2(буква)Type: строка - тип выражения в интерпретаторе.

-- Ответ:
answer2a :: String
answer2a = "2"

answer2aType :: String
answer2aType = "1 + 1 :: Num a => a"

answer2b :: String
answer2b = "False"

answer2bType :: String
answer2bType = "True == False :: Bool"

answer2c :: String
answer2c = "-37"

answer2cType :: String
answer2cType = "5 + 7 * (-7 + 1) :: Num a => a"

answer2d :: String
answer2d = "False"

answer2dType :: String
answer2dType = "not True :: Bool"

answer2e :: String
answer2e = "True"

answer2eType :: String
answer2eType = "False && True || True :: Bool"

answer2f :: String
answer2f = "False"

answer2fType :: String
answer2fType = "2 * 2 /= 4 :: Bool"

answer2g :: String
answer2g = "10"

answer2gType :: String
answer2gType = "succ 9 :: (Enum a, Num a) => a"

answer2h :: String
answer2h = "18"

answer2hType :: String
answer2hType = "max 5 15 + 4 + min 9 (-1) :: (Ord a, Num a) => a"

-------------------------------------------------------------------------------
-- Упр. 3: Укажите эквивалент в языке Haskell следующего C/Java/Python выражения:
--              combine(prettify(lawn),construct(house,concrete))
--         a. combine prettify (lawn) construct (house concerete)
--         b. combine (prettify lawn (counstruct house concrete))
--         c. combine (prettify lawn) (construct house concrete)

-- Ответ:
answer3 :: Char
answer3 = 'c'

-------------------------------------------------------------------------------
-- Упр. 4: Какой эквивалент C/Java/Python для Haskell выражения:
--              send metric (double population + increase)
--         a.  send(metric(double(population+increase)))
--         b.  send(metric(double(population)+increase))
--         c.  send(metric,double(population)+increase)
--         d.  send(metric,double(population+increase))

-- Ответ:
answer4 :: Char
answer4 = 'b'

-------------------------------------------------------------------------------
-- Упр. 5: Используя только функцию max из модуля Prelude:
--              max :: Int -> Int -> Int
--              max x y = `если x > y, то x, иначе y`
--         напишите выражение,  которые  находит  максимальное  число  среди
--         списка чисел:
--              0, -2, 99, 11, -5, 6, 1521

-- Ответ:
task_03_05_num1 :: Int
task_03_05_num1 = 0

task_03_05_num2 :: Int
task_03_05_num2 = -2

task_03_05_num3 :: Int
task_03_05_num3 = 99

task_03_05_num4 :: Int
task_03_05_num4 = 11

task_03_05_num5 :: Int
task_03_05_num5 = -5

task_03_05_num6 :: Int
task_03_05_num6 = 6

task_03_05_num7 :: Int
task_03_05_num7 = 1521

answer5 :: Int
answer5 = max (max (max (max (max (max task_03_05_num1 task_03_05_num2) task_03_05_num3) task_03_05_num4) task_03_05_num5) task_03_05_num6) task_03_05_num7

-------------------------------------------------------------------------------
-- Упр. 6: Создайте модуль FACTORIAL:
--            module FACTORIAL where
--
--            fac :: Int -> Int
--            fac 0 = 1
--            fac n = n * fac (n - 1)
--
-- Загрузите модуль в интерпретатор, использую команду:
--    :load `имя_файла_модуля`
-- Команда :load будет искать указанный файл в текущем каталоге.

-- Ответ:
--     ghci> :load factorial.hs
--     [1 of 1] Compiling FACTORIAL        ( factorial.hs, interpreted )
--     Ok, one module loaded.

-- Упр. 7: Вычислите fac 5.

-- Ответ:
answer7 :: Int
answer7 = 120

-------------------------------------------------------------------------------
-- Упр. 8: Используя условное выражение напишите функцию, которая возвращает 0,
-- если её аргумент больше 5, иначе возвращает 1

-- Ответ:
isLessThanFive :: Integer -> Integer
isLessThanFive n = if n > 5 then 0 else 1

-------------------------------------------------------------------------------
-- Упр. 9: Напишите функцию isZero, которая получает значение типа Integer
-- и возвращает True, если полученное значение равно 0 и False иначе. Укажите
-- сигнатуру функции isZero.

-- Примечания:
--   a. Используйте только сравнение с образцом, не используйте функцию сравнения.
--   b. Тип логических значений в Haskell – это Bool.
--   c. Сигнатура в Haskell имеет вид:
--                    имя_определения :: тип определения

-- Ответ:
isZero :: Integer -> Bool
isZero n
  | n == 0 = True
  | otherwise = False

isZeroSignature :: String
isZeroSignature = "isZero :: Integer -> Bool"

-------------------------------------------------------------------------------
-- Упр. 10: Реализуйте функцию max’, которая находит максимальное число из 3-х
-- заданных чисел.

-- Ответ:
max' :: Int -> Int -> Int -> Int
max' a b c = max (max a b) c

-------------------------------------------------------------------------------
-- Упр. 11: Напишите выражение, которое конкатенирует строки:
--             “Hello”, “ ”, “world”, “!”.

-- Ответ:
answer11 :: String
answer11 = "Hello" ++ " " ++ "world" ++ "!"

-------------------------------------------------------------------------------
-- Упр. 12: Используя команду :info (++) определите ассоциативность
-- оператора (++).
--  a. Левоассоциативная
--  b. Правоассоциативная
--  c. Ассоциативная

-- Ответ:
answer12 :: Char
answer12 = 'b'

-------------------------------------------------------------------------------
-- Упр. 13: Используя команды :info (++) и :info (^) определите какой оператор
-- имеет больший приоритет (++) или (^).
--  a. (++)
--  b. (^)

-- Ответ:
answer13 :: Char
answer13 = 'b'

-------------------------------------------------------------------------------
-- Упр. 14: Расставьте скобки в выражении 2^4 + 6 * 3^2 – 1, в соответствии с
-- приоритетом операций в Haskell
--
-- Примечание: в качестве ответа запишите получившееся выражение.

-- Ответ:
answer14 :: String
answer14 = "(((2^4) + (6 * (3^2))) – 1)"

-------------------------------------------------------------------------------
-- Упр. 15. Используя команду :t `выражение` определите тип
--   a.  функции max;
--   b.  функции head;
--   c.  выражения 2 + 2;
--   d.  оператора (^).

-- Ответ:
answer15a :: String
answer15a = "max :: Ord a => a -> a -> a"

answer15b :: String
answer15b = "head :: GHC.Stack.Types.HasCallStack => [a] -> a"

answer15c :: String
answer15c = "(2+2) :: Num a => a"

answer15d :: String
answer15d = "(^) :: (Num a, Integral b) => a -> b -> a"

-------------------------------------------------------------------------------
-- Упр. 16: Запишите все операторы в выражениях в префиксной нотации:
--   a.  1 + 2
--   b.  4^2 – 1
--   c.  5 == 6 - 1

-- Ответ:
answer16a :: String
answer16a = "(+) 1 2"

answer16b :: String
answer16b = "(-) ((^) 4 2) 1"

answer16c :: String
answer16c = "(==) 5 ((-) 6 1)"

-------------------------------------------------------------------------------
-- Упр. 17: Запишите все операторы выражениях в инфиксной нотации:
--   a.  max 5 (-1)
--   b.  min (min 5 2) (max (-1) 4)

-- Ответ:
answer17a :: String
answer17a = "5 `max` (-1)"

answer17b :: String
answer17b = "5 `min` 2 `min` ((-1) `max` 4)"

-------------------------------------------------------------------------------
-- Упр. 18: Запишите список чисел:
--   a. [2,3,4,5] без перечисления всех элементов списка.
--   b. [1,3,5,7,9] без перечисления всех элементов списка.

-- Ответ:
answer18a :: String
answer18a = "[2..5]"

answer18b :: String
answer18b = "[1,3..9]"

-------------------------------------------------------------------------------
-- Упр. 19: Напишите выражение, которое вычисляет из списка [1, 5, -3, 3, 5]:
--   a.  голову списка;
--   b.  хвост списка;
--   c.  новый список, который состоит из первых трёх элементов списка;
--   d.  новый список, который состоит из квадратов элементов списка (используйте, генераторы списка)
--   e.  новый список, который содержит умноженные на 2 элементы списка, которые при умножении на три больше 8.

-- Ответ:
answer19a :: String
answer19a = "head [1, 5, -3, 3, 5]"

answer19b :: String
answer19b = "tail [1, 5, -3, 3, 5]"

answer19c :: String
answer19c = "take 3 [1, 5, -3, 3, 5]"

answer19d :: String
answer19d = "[x*x | x <- [1,5,-3,3,5]]"

answer19e :: String
answer19e = "[x*2 | x <- filter(\\x->x*3>8) [1,5,-3,3,5]]"

-- Упр. 20: Напишите функцию, которая для данного числа n создаёт список всех
--  попарных сумм чисел от 1 до n (Т.е. [1+1, 1+2, 1+3,…,1+n, 2+1, 2+2,…,n+n]
--  всего n*n элементов)
--
-- Примечание: Используйте генераторы списков.

-- Ответ:
answer20 :: Int -> [Int]
answer20 n = [x + y | x <- [1 .. n], y <- [1 .. n]]

-------------------------------------------------------------------------------
-- Упр. 21: Перепишите функцию используя охранные выражения:
--
--   f :: Int -> Int -> Int
--   f x y =
--     if x > y + 1      then 0 else
--     if x > y - 2      then 1 else
--     if x * 2  == y + 1 then 2 else
--     if x + 10 == y - 2 then 3 else 4
--
--  Используйте конструкцию where, чтобы ввести локальные определения для
--  подвыражений y + 1 и y – 2

-- Ответ:
f :: Int -> Int -> Int
f x y
  | x > yPlusOne = 0
  | x > yMinusTwo = 1
  | xDoubled == yPlusOne = 2
  | xPlusTen == yMinusTwo = 3
  | otherwise = 4
  where
    yPlusOne = y + 1
    yMinusTwo = y - 2
    xDoubled = x * 2
    xPlusTen = x + 10

-------------------------------------------------------------------------------
-- Упр. 22: Используя сравнение с образцом реализуйте функции:

-- Ответ:
fst' :: (a, b, c) -> a
fst' (a, _, _) = a

snd' :: (a, b, c) -> b
snd' (_, b, _) = b

thd' :: (a, b, c) -> c
thd' (_, _, c) = c

-------------------------------------------------------------------------------
-- Упр. 23: Напишите функцию distance, которая получает четыре значения типа
-- Dobule: x1, y1, x2, y2 и возвращает евклидовое расстояние между двумя
-- точками (x1, y1) и (x2, y2). Укажите сигнатуру функции distance.

-- Ответ:
distance :: Double -> Double -> Double -> Double -> Double
distance x1 y1 x2 y2 = sqrt ((x2 - x1) ^ 2 + (y2 - y1) ^ 2)

-------------------------------------------------------------------------------
-- Упр. 24: Напишите  функцию add_and_double,  которая складывает два  числа, а
-- затем умножает результат сложения на два.

-- Ответ:
add_and_double :: Int -> Int -> Int
add_and_double x y = (x + y) * 2

-------------------------------------------------------------------------------
-- Упр. 25: Используя  функцию add_and_double  реализуйте инфиксный оператор +*,
-- который делает тоже самое, что и функция add_and_double.

-- Ответ:
(+*) :: Int -> Int -> Int
(+*) = add_and_double

-------------------------------------------------------------------------------
-- Упр. 26: Напишите функцию solve_quadratic_equation от трёх аргументов
-- a, b и c, которые являются коэффициентами квадратного уравнения
-- x2 + b x + c = 0. a, b, c, и x должны быть типа  Double. Результатом должна
-- быть пара корней уравнения (кортеж двух значений). В случае комплексных
-- корней, применение функции sqrt (находит квадратный корень) к отрицательному
-- числу вернёт NaN (Not A Number). Используйте let-выражение или конструкцию
-- where для определения квадратного корня дискриминанта уравнения.

-- Ответ:
solve_quadratic_equation :: Double -> Double -> Double -> (Double, Double)
solve_quadratic_equation a b c =
  (x1, x2)
  where
    d = b ** 2 - 4 * a * c
    x1 = (-b + sqrt d) / (2 * a)
    x2 = (-b - sqrt d) / (2 * a)

-------------------------------------------------------------------------------
-- Упр. 27: Определите функцию  double_factorial, которая получает целое число n
-- и вычисляет произведение всех факториалов начиная с нуля и включая n.
-- Используйте let-выражения или конструкцию where для определения функции
-- факториала.

-- Ответ:
double_factorial :: Integer -> Integer
double_factorial n = product fac_list
  where
    fac :: Integer -> Integer
    fac 0 = 1
    fac m = m * fac (m - 1)
    fac_list :: [Integer]
    fac_list = [fac k | k <- [0 .. n]]

-------------------------------------------------------------------------------
-- Упр. 28: Напишите  функцию ilog3. Функция должна вычислять сколько  раз можно
-- полученное значение аргумента разделить на 3 (с округлением в меньшую сторону)
-- прежде, чем будет получен 0.
--
-- Пример:
--   ilog3 20 ==> 3 т.к.
--     --   20/3 = 6.66 (округляется до 6)
-- --   6/3 = 2
-- --   2/3 = 0.666 (округляется до 0)
-- ilog3 2 ==> 1
-- ilog3 7 ==> 2
--
-- Используйте функцию целочисленного деления div для деления целых чисел.

-- Ответ:
ilog3 :: Integer -> Integer
ilog3 0 = 0
ilog3 n = 1 + ilog3 (div n 3)